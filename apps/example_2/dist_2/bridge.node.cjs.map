{
  "version": 3,
  "sources": ["../../runtime/src/env.ts", "../../runtime/src/worker-call.ts", "../../runtime/src/worker-helper.ts", "../src/bridge.ts"],
  "sourcesContent": [
    "/**\n * Runtime environment detection utilities\n */\n\n/**\n * Detect if running in a Web Worker context\n */\nexport function isWorker(): boolean {\n  return (\n    typeof self !== 'undefined' &&\n    typeof (globalThis as unknown as { DedicatedWorkerGlobalScope?: unknown })\n      .DedicatedWorkerGlobalScope !== 'undefined'\n  );\n}\n\n/**\n * Detect if running in a browser context\n */\nexport function isBrowser(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * Detect if running in Bun\n */\nexport function isBun(): boolean {\n  return typeof Bun !== 'undefined';\n}\n\n/**\n * Detect if running in Node.js\n */\nexport function isNode(): boolean {\n  return (\n    typeof process !== 'undefined' &&\n    process.versions != null &&\n    process.versions.node != null\n  );\n}\n\n/**\n * Check if ImageData is available in the current environment\n */\nexport function hasImageData(): boolean {\n  return typeof ImageData !== 'undefined';\n}\n",
    "/**\n * Generic worker communication helper with support for transferables and AbortSignal\n */\n\nexport interface WorkerRequest<T = unknown> {\n  type: string;\n  id: number;\n  payload: T;\n}\n\nexport interface WorkerResponse<T = unknown> {\n  id: number;\n  ok: boolean;\n  data?: T;\n  error?: string;\n}\n\nlet requestId = 0;\n\n/**\n * Call a worker with a typed request and wait for response\n *\n * @param worker - The worker instance to call\n * @param type - The message type\n * @param payload - The payload to send\n * @param signal - Optional AbortSignal to cancel the operation\n * @param transfer - Optional list of Transferable objects to transfer\n * @returns Promise that resolves with the worker's response data\n */\nexport async function callWorker<TPayload, TResponse>(\n  worker: Worker,\n  type: string,\n  payload: TPayload,\n  signal?: AbortSignal,\n  transfer?: Transferable[]\n): Promise<TResponse> {\n  return new Promise<TResponse>((resolve, reject) => {\n    const id = ++requestId;\n\n    // Check if already aborted\n    if (signal?.aborted) {\n      reject(new DOMException('Aborted', 'AbortError'));\n      return;\n    }\n\n    const handleMessage = (event: MessageEvent) => {\n      const response = event.data as WorkerResponse<TResponse>;\n      if (response.id !== id) return;\n\n      cleanup();\n\n      if (response.ok && response.data !== undefined) {\n        resolve(response.data);\n      } else {\n        reject(new Error(response.error || 'Unknown worker error'));\n      }\n    };\n\n    const handleError = (error: ErrorEvent) => {\n      cleanup();\n      reject(new Error(`Worker error: ${error.message}`));\n    };\n\n    const handleAbort = () => {\n      cleanup();\n      reject(new DOMException('Aborted', 'AbortError'));\n    };\n\n    const cleanup = () => {\n      worker.removeEventListener('message', handleMessage);\n      worker.removeEventListener('error', handleError);\n      signal?.removeEventListener('abort', handleAbort);\n    };\n\n    // Set up listeners\n    worker.addEventListener('message', handleMessage);\n    worker.addEventListener('error', handleError);\n    signal?.addEventListener('abort', handleAbort);\n\n    // Send the request\n    const request: WorkerRequest<TPayload> = { type, id, payload };\n\n    if (transfer && transfer.length > 0) {\n      worker.postMessage(request, transfer);\n    } else {\n      worker.postMessage(request);\n    }\n  });\n}\n",
    "/**\n * Worker helper utilities for creating and managing Web Workers\n *\n * This module provides centralized logic for creating worker instances\n * in different environments (browser, Node.js, Bun) using import.meta.resolve\n * for server-side and package-relative paths for browsers.\n */\n\nimport { isBun } from './env';\n\n/**\n * Create a Web Worker for a specific codec\n *\n * In Node.js/Bun environments, uses import.meta.resolve to locate worker files.\n * In browser environments, uses relative paths within node_modules that Vite can resolve.\n *\n * @param workerFilename - The name of the worker file (e.g., 'resize.worker' or 'webp.worker')\n * @returns Worker instance\n * @throws Error if worker creation fails with detailed error message\n */\nexport function createCodecWorker(workerFilename: string): Worker {\n  // Ensure filename has correct format\n  const normalizedName = workerFilename.endsWith('.js')\n    ? workerFilename\n    : `${workerFilename}.js`;\n\n  // Map worker filenames to their package and export\n  const workerMap: Record<string, { package: string; specifier: string }> = {\n    'resize.worker.js': {\n      package: '@squoosh-kit/resize',\n      specifier: 'resize.worker.js',\n    },\n    'webp.worker.js': {\n      package: '@squoosh-kit/webp',\n      specifier: 'webp.worker.js',\n    },\n    'avif.worker.js': {\n      package: '@squoosh-kit/avif',\n      specifier: 'avif.worker.js',\n    },\n    'mozjpeg.worker.js': {\n      package: '@squoosh-kit/mozjpeg',\n      specifier: 'mozjpeg.worker.js',\n    },\n    'jxl.worker.js': {\n      package: '@squoosh-kit/jxl',\n      specifier: 'jxl.worker.js',\n    },\n  };\n\n  const workerConfig = workerMap[normalizedName];\n  if (!workerConfig) {\n    throw new Error(\n      `Unknown worker: ${normalizedName}. ` +\n        `Supported workers: ${Object.keys(workerMap).join(', ')}`\n    );\n  }\n\n  try {\n    // In browser contexts, use relative paths within the installed packages\n    if (typeof window !== 'undefined') {\n      const packageName = workerConfig.package.split('/')[1]; // Extract 'resize' or 'webp'\n      const workerFile = normalizedName.replace('.js', '.browser.mjs');\n\n      // Try multiple path strategies to support both:\n      // 1. Monorepo development structure: ../../{package}/dist/{workerFile}\n      // 2. npm installed structure: ../../../{package}/dist/{workerFile}\n      const pathStrategies = [\n        // First try monorepo structure (when runtime is at packages/runtime/src)\n        `../../${packageName}/dist/${workerFile}`,\n        // Then try npm structure (when runtime is at node_modules/@squoosh-kit/runtime)\n        `../../../node_modules/@squoosh-kit/${packageName}/dist/${workerFile}`,\n        // Alternative npm structure for cases where packages are flattened\n        `../../../${packageName}/dist/${workerFile}`,\n      ];\n\n      let lastError: Error | null = null;\n\n      for (const relPath of pathStrategies) {\n        try {\n          const workerUrl = new URL(relPath, import.meta.url);\n          return new Worker(workerUrl, {\n            type: 'module',\n          });\n        } catch (error) {\n          lastError = error instanceof Error ? error : new Error(String(error));\n          // Continue to next strategy\n        }\n      }\n\n      // If all strategies failed, throw the last error\n      if (lastError) {\n        throw lastError;\n      }\n      throw new Error(\n        `Could not resolve worker ${normalizedName} using any available path strategy`\n      );\n    }\n\n    // Fallbacks for monorepo/dev without build artifacts\n    const platformExt = isBun() ? '.bun.js' : '.node.mjs';\n    const baseName = normalizedName.replace('.js', '');\n\n    // 1) Try TypeScript source first (Bun can transpile TS, works in dev)\n    let srcRelPath = '';\n    if (workerConfig.package.includes('resize')) {\n      srcRelPath = `../../resize/src/${baseName}.ts`;\n    } else if (workerConfig.package.includes('webp')) {\n      srcRelPath = `../../webp/src/${baseName}.ts`;\n    } else if (workerConfig.package.includes('avif')) {\n      srcRelPath = `../../avif/src/${baseName}.ts`;\n    } else if (workerConfig.package.includes('mozjpeg')) {\n      srcRelPath = `../../mozjpeg/src/${baseName}.ts`;\n    } else if (workerConfig.package.includes('jxl')) {\n      srcRelPath = `../../jxl/src/${baseName}.ts`;\n    }\n\n    if (srcRelPath) {\n      try {\n        return new Worker(new URL(srcRelPath, import.meta.url), {\n          type: 'module',\n        });\n      } catch {\n        // Continue to next fallback\n      }\n    }\n\n    // 2) Try dist output (if already built)\n    let distRelPath = '';\n    if (workerConfig.package.includes('resize')) {\n      distRelPath = `../../resize/dist/${baseName}.${platformExt.slice(1)}`;\n    } else if (workerConfig.package.includes('webp')) {\n      distRelPath = `../../webp/dist/${baseName}.${platformExt.slice(1)}`;\n    } else if (workerConfig.package.includes('avif')) {\n      distRelPath = `../../avif/dist/${baseName}.${platformExt.slice(1)}`;\n    } else if (workerConfig.package.includes('mozjpeg')) {\n      distRelPath = `../../mozjpeg/dist/${baseName}.${platformExt.slice(1)}`;\n    } else if (workerConfig.package.includes('jxl')) {\n      distRelPath = `../../jxl/dist/${baseName}.${platformExt.slice(1)}`;\n    }\n\n    if (distRelPath) {\n      try {\n        return new Worker(new URL(distRelPath, import.meta.url), {\n          type: 'module',\n        });\n      } catch {\n        // Continue to next fallback\n      }\n    }\n\n    // 3) Try import.meta.resolve as last resort\n    if (typeof import.meta.resolve === 'function') {\n      try {\n        const resolved = import.meta.resolve(\n          `${workerConfig.package}/${workerConfig.specifier}`\n        );\n        return new Worker(resolved, { type: 'module' });\n      } catch {\n        // Continue to error below\n      }\n    }\n\n    // If we get here, all fallbacks failed\n    throw new Error(\n      `Failed to create worker from ${normalizedName}. ` +\n        `Tried TypeScript source, dist output, and import.meta.resolve. ` +\n        `Ensure the @squoosh-kit/resize and @squoosh-kit/webp packages are installed.`\n    );\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    throw new Error(\n      `Failed to create worker from ${normalizedName}: ${errorMessage}. ` +\n        `Ensure the @squoosh-kit/resize and @squoosh-kit/webp packages are installed. ` +\n        `If you're using Vite, ensure the worker files are not being optimized as dependencies.`\n    );\n  }\n}\n\n/**\n * Create a worker with initialization timeout and ready signal handling\n *\n * This is a higher-level function that creates a worker and waits for it\n * to signal that it's ready to receive messages.\n *\n * @param workerFilename - The name of the worker file\n * @param timeoutMs - Timeout in milliseconds (default: 10000)\n * @returns Promise that resolves to a ready Worker instance\n * @throws Error if worker creation fails or times out\n */\nexport function createReadyWorker(\n  workerFilename: string,\n  timeoutMs: number = 10000\n): Promise<Worker> {\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      reject(\n        new Error(\n          `Worker initialization timeout after ${timeoutMs}ms. Worker file: ${workerFilename}`\n        )\n      );\n    }, timeoutMs);\n\n    let worker: Worker;\n    try {\n      worker = createCodecWorker(workerFilename);\n    } catch (error) {\n      clearTimeout(timeout);\n      reject(error);\n      return;\n    }\n\n    const handleMessage = (event: MessageEvent) => {\n      if (event.data?.type === 'worker:ready') {\n        clearTimeout(timeout);\n        worker.removeEventListener('message', handleMessage);\n        worker.removeEventListener('error', handleError);\n        worker.removeEventListener('messageerror', handleMessageError);\n        resolve(worker);\n      }\n    };\n\n    const handleError = (event: ErrorEvent) => {\n      clearTimeout(timeout);\n      worker.removeEventListener('message', handleMessage);\n      worker.removeEventListener('error', handleError);\n      worker.removeEventListener('messageerror', handleMessageError);\n      reject(\n        new Error(\n          `Worker failed to start: ${event?.message || 'Unknown error'}. Worker file: ${workerFilename}`\n        )\n      );\n    };\n\n    const handleMessageError = () => {\n      clearTimeout(timeout);\n      worker.removeEventListener('message', handleMessage);\n      worker.removeEventListener('error', handleError);\n      worker.removeEventListener('messageerror', handleMessageError);\n      reject(\n        new Error(\n          `Worker message error during initialization. Worker file: ${workerFilename}`\n        )\n      );\n    };\n\n    worker.addEventListener('message', handleMessage);\n    worker.addEventListener('error', handleError);\n    worker.addEventListener('messageerror', handleMessageError);\n    worker.postMessage({ type: 'worker:ping' });\n  });\n}\n",
    "/**\n * Bridge implementation for the AVIF package, handling worker and client modes.\n */\n\nimport {\n  callWorker,\n  createReadyWorker,\n  type ImageInput,\n} from '@squoosh-kit/runtime';\nimport { validateImageInput } from '@squoosh-kit/runtime';\nimport type { AvifEncodeInputOptions } from './types';\n\ninterface AvifBridge {\n  encode(\n    image: ImageInput,\n    options?: AvifEncodeInputOptions,\n    signal?: AbortSignal\n  ): Promise<Uint8Array>;\n  decode(buffer: BufferSource, signal?: AbortSignal): Promise<ImageData>;\n  terminate(): Promise<void>;\n}\n\nclass AvifClientBridge implements AvifBridge {\n  async encode(\n    image: ImageInput,\n    options?: AvifEncodeInputOptions,\n    signal?: AbortSignal\n  ): Promise<Uint8Array> {\n    const module = await import('./avif.worker.js');\n    const avifEncodeClient = module.avifEncodeClient as (\n      image: ImageInput,\n      options?: AvifEncodeInputOptions,\n      signal?: AbortSignal\n    ) => Promise<Uint8Array>;\n    return avifEncodeClient(image, options, signal);\n  }\n\n  async decode(buffer: BufferSource, signal?: AbortSignal): Promise<ImageData> {\n    const module = await import('./avif.worker.js');\n    const avifDecodeClient = module.avifDecodeClient as (\n      buffer: BufferSource,\n      signal?: AbortSignal\n    ) => Promise<ImageData>;\n    return avifDecodeClient(buffer, signal);\n  }\n\n  async terminate(): Promise<void> {\n    // Client mode has nothing to terminate\n  }\n}\n\nclass AvifWorkerBridge implements AvifBridge {\n  private worker: Worker | null = null;\n  private workerReady: Promise<Worker> | null = null;\n\n  private async getWorker(): Promise<Worker> {\n    if (!this.worker) {\n      if (!this.workerReady) {\n        this.workerReady = this.createWorker();\n      }\n      this.worker = await this.workerReady;\n    }\n    return this.worker;\n  }\n\n  private async createWorker(): Promise<Worker> {\n    return createReadyWorker('avif.worker');\n  }\n\n  async encode(\n    image: ImageInput,\n    options?: AvifEncodeInputOptions,\n    signal?: AbortSignal\n  ): Promise<Uint8Array> {\n    const worker = await this.getWorker();\n    validateImageInput(image);\n    return callWorker(worker, 'avif:encode', { image, options }, signal);\n  }\n\n  async decode(buffer: BufferSource, signal?: AbortSignal): Promise<ImageData> {\n    const worker = await this.getWorker();\n    return callWorker(worker, 'avif:decode', { buffer }, signal);\n  }\n\n  async terminate(): Promise<void> {\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n      this.workerReady = null;\n    }\n  }\n}\n\nexport function createBridge(mode: 'worker' | 'client'): AvifBridge {\n  return mode === 'client' ? new AvifClientBridge() : new AvifWorkerBridge();\n}\n"
  ],
  "mappings": "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",
  "debugId": "213C3D6EA6D3EE5164756E2164756E21",
  "names": []
}